
// ** vector v0.3
#include <iostream>

using namespace std;

int main(void)
{
	char str1[2][5] = {
		{'A','B','C','D','E'},
		{'F','G','H','I','J'}
	};

	char* str2[2] = {
		{(char*)"ABCD"},
		{(char*)"EFGH"}
	}; 

	for (int i = 0; i < 5; i + 1);
	cout << (*str1)[1];

	cout << endl;


	// 직접 접근으로 하나의 알파벳을 추가해볼것

	return 0;
}

// 벡터의 구조는 배열과 동일하다.

// 배열의 장점
/*
	1. 직접 접근이 가능하다. (이게 되는 자료구조가 별로 없다) ★★★★★
	2. 동일한 크기로 나열이 되므로 접근 속도가 항상 일정하다. 
*/

// 배열의 단점(치명적임)
/*
	1. 배열의 동적 선언이 되지 않는다. (길이를 한 번 정하면 바꿀 수 없다.)
	2. 특정 데이터의 정확한 위치는 알 수 없다.
*/

// 벡터를 사용할 때 주의할 점
/*
	
*/

// 이동과 복제의 차이
/*
	복제: 데이터를 복제만 한다.
	이동: 데이터를 복제하고 기존 데이터를 삭제한다.

	복사를 많이 할 수록 느려지기 마련이므로
	길이를 늘이고 줄일 수 있는 방법이 있다 해도 복사를 많이 해야 될 가능성이 있기 때문에
	좋지는 않다.
*/

// 배열'만' 사용할 때
/*
	일단 여분을 많이 만들어두고, 필요한 만큼만 가져다쓴다.
	부하가 있을지는 모르지만, 데이터를 늘려야 할 때 유용하다. (벡터가 나오기 전 이야기)
*/

// 2차 배열이라 하더라도 '1열로 나열되어 있다'

//=====================================================

// ** 1. 데이터 추가 (새로운 공간 확보)


// ** 2. 데이터 삭제 (삭제하기 의해 생성하는 것이 아니다)
/*
이미지(텍스쳐)를 불러오거나 할 때 한번에 불러와서 필요할 때 갖다 쓰는 용도
데이터를 불러올 때는 '문자열'의 형태로 불러오게 됨
각각 구분이 되어 있어야 한다. {(123 / 456)O / (1234 / 56)X}
배열의 형태로 가져오면 수월하게 가져올 수 있다

*/

// ** 3. 데이터를 삽입할 수 있는 공간의 크기

// ** 4. 현재 삽입되어있는 원소의 개수

// ** 5. 컨테이너에 시작 지점

// ** 6. 컨테이너의 종료 지점

/*

[보기]->Ctrl M(팀 탐색기)

설치 방법 : visual studio installer->개별 구성 요소->visual studio 용 github

*/

// git 사용법: pull 작업 push